# Firebase Firestore Schema for Nunta360

This document defines the Firestore database schema for migrating from Supabase to Firebase.

## Authentication

Firebase Authentication will replace Supabase Auth. User authentication will be handled by Firebase Auth with the following providers:
- Email/Password
- (Future: Google, Facebook, etc.)

The `auth.uid()` in Supabase RLS policies translates to Firebase Auth UID accessible via `request.auth.uid` in Security Rules.

---

## Collections

### 1. `users` Collection

**Path:** `/users/{userId}`

**Document ID:** Firebase Auth UID (string)

**Document Structure:**
```typescript
{
  id: string;                    // Same as document ID (Firebase Auth UID)
  fullName: string;              // User's full name
  email: string;                 // User's email (indexed)
  role: string;                  // Default: 'user'
  createdAt: Timestamp;          // Firebase Timestamp
  updatedAt: Timestamp;          // Firebase Timestamp
}
```

**Indexes:**
- Single field index on `email` (for lookups/uniqueness check)

**Security Rules:**
```javascript
match /users/{userId} {
  // Users can read their own profile
  allow read: if request.auth.uid == userId;

  // Users can create their own profile on signup
  allow create: if request.auth.uid == userId
                && request.resource.data.email == request.auth.token.email;

  // Users can update their own profile
  allow update: if request.auth.uid == userId;

  // No delete allowed
  allow delete: if false;
}
```

---

### 2. `events` Collection

**Path:** `/users/{userId}/events/{eventId}`

**Document ID:** Auto-generated by Firestore

**Document Structure:**
```typescript
{
  id: string;                    // Same as document ID
  userId: string;                // References parent user document
  brideName: string;             // Bride's name
  groomName: string;             // Groom's name
  weddingDate: Timestamp;        // Wedding date (Firebase Timestamp)
  createdAt: Timestamp;          // Firebase Timestamp
  updatedAt: Timestamp;          // Firebase Timestamp
}
```

**Subcollection of:** `users`

**Why Subcollection:**
- Events are tightly coupled to users
- Automatic cascading delete when user is deleted
- Simpler security rules
- Better data locality

**Security Rules:**
```javascript
match /users/{userId}/events/{eventId} {
  // Users can read their own events
  allow read: if request.auth.uid == userId;

  // Users can create their own events
  allow create: if request.auth.uid == userId
                && request.resource.data.userId == userId;

  // Users can update their own events
  allow update: if request.auth.uid == userId;

  // Users can delete their own events
  allow delete: if request.auth.uid == userId;
}
```

---

### 3. `guests` Collection

**Path:** `/users/{userId}/guests/{guestId}`

**Document ID:** Auto-generated by Firestore

**Document Structure:**
```typescript
{
  id: string;                    // Same as document ID
  userId: string;                // References parent user document
  name: string;                  // Guest name (indexed for search)
  phoneNumber?: string;          // Optional phone number
  isFamily: boolean;             // Default: false
  familySize: number;            // Default: 1, minimum: 1
  status: 'in_asteptare' | 'confirmat' | 'refuzat';  // Default: 'in_asteptare'
  menuPreference: 'normal' | 'vegetarian' | 'vegan' | 'fara_gluten' | 'alte_alergii';  // Default: 'normal'
  familyMembers: string[];       // Array of family member names
  createdAt: Timestamp;          // Firebase Timestamp
  updatedAt: Timestamp;          // Firebase Timestamp
}
```

**Subcollection of:** `users`

**Composite Indexes:**
- `userId` + `status` (for filtering guests by status)
- `userId` + `menuPreference` (for filtering guests by menu)
- `userId` + `isFamily` (for filtering family guests)

**Note:** Firestore doesn't support array indexes like PostgreSQL's GIN index. Array queries on `familyMembers` will use array-contains operator.

**Validation Constraints (enforced in Security Rules):**
- `familySize >= 1`
- If `isFamily == false`, then `familySize == 1`
- If `isFamily == true`, then `familySize > 1`
- `status` must be one of: 'in_asteptare', 'confirmat', 'refuzat'
- `menuPreference` must be one of: 'normal', 'vegetarian', 'vegan', 'fara_gluten', 'alte_alergii'

**Security Rules:**
```javascript
match /users/{userId}/guests/{guestId} {
  // Helper function to validate guest data
  function isValidGuest() {
    let data = request.resource.data;
    return data.familySize >= 1
           && (data.isFamily == false ? data.familySize == 1 : data.familySize > 1)
           && data.status in ['in_asteptare', 'confirmat', 'refuzat']
           && data.menuPreference in ['normal', 'vegetarian', 'vegan', 'fara_gluten', 'alte_alergii'];
  }

  // Users can read their own guests
  allow read: if request.auth.uid == userId;

  // Users can create their own guests with validation
  allow create: if request.auth.uid == userId
                && request.resource.data.userId == userId
                && isValidGuest();

  // Users can update their own guests with validation
  allow update: if request.auth.uid == userId
                && isValidGuest();

  // Users can delete their own guests
  allow delete: if request.auth.uid == userId;
}
```

---

### 4. `tableGuests` Collection

**Path:** `/users/{userId}/tableGuests/{tableGuestId}`

**Document ID:** Auto-generated by Firestore

**Document Structure:**
```typescript
{
  id: string;                    // Same as document ID
  userId: string;                // References parent user document
  name: string;                  // Guest name
  tableId: string;               // Venue object ID from canvas
  tableName?: string;            // Display name of the table
  eventId?: string;              // For future multi-event support
  guestId?: string;              // References guest document ID (from guests collection)
  createdAt: Timestamp;          // Firebase Timestamp
  updatedAt: Timestamp;          // Firebase Timestamp
}
```

**Subcollection of:** `users`

**Composite Indexes:**
- `userId` + `tableId` (for querying guests at a specific table)
- `userId` + `eventId` (for querying guests for a specific event)
- `userId` + `guestId` (for linking to main guest record)

**Security Rules:**
```javascript
match /users/{userId}/tableGuests/{tableGuestId} {
  // Users can read their own table assignments
  allow read: if request.auth.uid == userId;

  // Users can create their own table assignments
  allow create: if request.auth.uid == userId
                && request.resource.data.userId == userId;

  // Users can update their own table assignments
  allow update: if request.auth.uid == userId;

  // Users can delete their own table assignments
  allow delete: if request.auth.uid == userId;
}
```

---

### 5. `budget` Collection

**Path:** `/users/{userId}/budget/{budgetId}`

**Document ID:** Auto-generated by Firestore

**Document Structure:**
```typescript
{
  id: string;                    // Same as document ID
  userId: string;                // References parent user document
  totalBudget: number;           // Total budget amount in euros
  createdAt: Timestamp;          // Firebase Timestamp
  updatedAt: Timestamp;          // Firebase Timestamp
}
```

**Subcollection of:** `users`

**Why Subcollection:**
- Budget is tightly coupled to users
- Automatic cascading delete when user is deleted
- Simpler security rules
- Better data locality

**Security Rules:**
```javascript
match /users/{userId}/budget/{budgetId} {
  // Users can read their own budget
  allow read: if request.auth.uid == userId;

  // Users can create their own budget
  allow create: if request.auth.uid == userId
                && request.resource.data.userId == userId;

  // Users can update their own budget
  allow update: if request.auth.uid == userId;

  // Users can delete their own budget
  allow delete: if request.auth.uid == userId;
}
```

---

### 6. `budget/categories` Collection

**Path:** `/users/{userId}/budget/{budgetId}/categories/{categoryId}`

**Document ID:** Auto-generated by Firestore

**Document Structure:**
```typescript
{
  id: string;                    // Same as document ID
  userId: string;                // References parent user document
  budgetId: string;              // References parent budget document
  category: 'Locație' | 'Catering' | 'Decorațiuni & Flori' | 'Fotograf & Videograf' | 'Muzică & Entertainment' | 'Rochie & Costum' | 'Altele';
  allocated: number;             // Allocated amount in euros
  createdAt: Timestamp;          // Firebase Timestamp
  updatedAt: Timestamp;          // Firebase Timestamp
}
```

**Subcollection of:** `budget`

**Valid Categories:**
- Locație
- Catering
- Decorațiuni & Flori
- Fotograf & Videograf
- Muzică & Entertainment
- Rochie & Costum
- Altele

**Validation Constraints (enforced in Security Rules):**
- `category` must be one of the valid categories listed above
- `allocated >= 0`

**Security Rules:**
```javascript
match /users/{userId}/budget/{budgetId}/categories/{categoryId} {
  function isValidCategory() {
    let data = request.resource.data;
    return data.category in ['Locație', 'Catering', 'Decorațiuni & Flori', 'Fotograf & Videograf', 'Muzică & Entertainment', 'Rochie & Costum', 'Altele']
           && data.allocated >= 0;
  }

  allow read: if request.auth.uid == userId;
  allow create: if request.auth.uid == userId
                && request.resource.data.userId == userId
                && isValidCategory();
  allow update: if request.auth.uid == userId
                && isValidCategory();
  allow delete: if request.auth.uid == userId;
}
```

---

### 7. `expenses` Collection

**Path:** `/users/{userId}/expenses/{expenseId}`

**Document ID:** Auto-generated by Firestore

**Document Structure:**
```typescript
{
  id: string;                    // Same as document ID
  userId: string;                // References parent user document
  name: string;                  // Expense name/description
  category: 'Locație' | 'Catering' | 'Decorațiuni & Flori' | 'Fotograf & Videograf' | 'Muzică & Entertainment' | 'Rochie & Costum' | 'Altele';
  price: number;                 // Price in euros
  createdAt: Timestamp;          // Firebase Timestamp
  updatedAt: Timestamp;          // Firebase Timestamp
}
```

**Subcollection of:** `users`

**Valid Categories:**
- Locație
- Catering
- Decorațiuni & Flori
- Fotograf & Videograf
- Muzică & Entertainment
- Rochie & Costum
- Altele

**Validation Constraints (enforced in Security Rules):**
- `category` must be one of the valid categories listed above
- `price >= 0`

**Security Rules:**
```javascript
match /users/{userId}/expenses/{expenseId} {
  function isValidExpense() {
    let data = request.resource.data;
    return data.category in ['Locație', 'Catering', 'Decorațiuni & Flori', 'Fotograf & Videograf', 'Muzică & Entertainment', 'Rochie & Costum', 'Altele']
           && data.price >= 0;
  }

  allow read: if request.auth.uid == userId;
  allow create: if request.auth.uid == userId
                && request.resource.data.userId == userId
                && isValidExpense();
  allow update: if request.auth.uid == userId
                && isValidExpense();
  allow delete: if request.auth.uid == userId;
}
```

---

## Alternative Schema Option: Top-Level Collections

If you prefer top-level collections instead of subcollections:

### Top-Level Structure
```
/users/{userId}
/events/{eventId}          // userId field for filtering
/guests/{guestId}          // userId field for filtering
/tableGuests/{tableGuestId} // userId field for filtering
/budget/{budgetId}         // userId field for filtering
/expenses/{expenseId}      // userId field for filtering
```

**Pros:**
- Easier to query across all users (for admin features)
- Simpler migration from relational DB

**Cons:**
- More complex security rules
- Need to manually handle cascading deletes
- More complex queries (always filter by userId)
- Higher potential for data leaks if security rules misconfigured

**Recommendation:** Use subcollections as shown above for better data isolation and automatic cleanup.

---

## Timestamp Handling

### Migration Notes:
- Supabase `TIMESTAMP WITH TIME ZONE` → Firebase `Timestamp`
- Auto-update timestamps need to be handled in application code (no triggers in Firestore)
- Use `serverTimestamp()` for createdAt and updatedAt fields

### Client-Side Timestamp Usage:
```typescript
import { serverTimestamp } from 'firebase/firestore';

// On create
{
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp()
}

// On update
{
  updatedAt: serverTimestamp()
}
```

---

## Data Migration Script Considerations

When migrating from Supabase to Firebase:

1. **Auth Migration:**
   - Export users from Supabase Auth
   - Import to Firebase Auth using Admin SDK
   - Map `auth_id` → Firebase Auth UID

2. **Data Migration:**
   - Use Firebase Admin SDK for batch writes
   - Convert UUID → Firestore auto-ID (or keep as string)
   - Convert PostgreSQL timestamps → Firebase Timestamps
   - Handle array fields (already supported in both)

3. **Relationship Mapping:**
   - `users.auth_id` → Use Firebase Auth UID as document ID
   - `events.user_id` → Parent path in subcollection
   - `guests.user_id` → Parent path in subcollection
   - `tableGuests.guest_id` → Keep as reference field

---

## Complete Security Rules File

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection
    match /users/{userId} {
      allow read: if request.auth.uid == userId;
      allow create: if request.auth.uid == userId
                    && request.resource.data.email == request.auth.token.email;
      allow update: if request.auth.uid == userId;
      allow delete: if false;

      // Events subcollection
      match /events/{eventId} {
        allow read: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId
                      && request.resource.data.userId == userId;
        allow update: if request.auth.uid == userId;
        allow delete: if request.auth.uid == userId;
      }

      // Guests subcollection
      match /guests/{guestId} {
        function isValidGuest() {
          let data = request.resource.data;
          return data.familySize >= 1
                 && (data.isFamily == false ? data.familySize == 1 : data.familySize > 1)
                 && data.status in ['in_asteptare', 'confirmat', 'refuzat']
                 && data.menuPreference in ['normal', 'vegetarian', 'vegan', 'fara_gluten', 'alte_alergii'];
        }

        allow read: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId
                      && request.resource.data.userId == userId
                      && isValidGuest();
        allow update: if request.auth.uid == userId
                      && isValidGuest();
        allow delete: if request.auth.uid == userId;
      }

      // Table guests subcollection
      match /tableGuests/{tableGuestId} {
        allow read: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId
                      && request.resource.data.userId == userId;
        allow update: if request.auth.uid == userId;
        allow delete: if request.auth.uid == userId;
      }

      // Budget subcollection
      match /budget/{budgetId} {
        allow read: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId
                      && request.resource.data.userId == userId;
        allow update: if request.auth.uid == userId;
        allow delete: if request.auth.uid == userId;

        // Budget categories subcollection
        match /categories/{categoryId} {
          function isValidCategory() {
            let data = request.resource.data;
            return data.category in ['Locație', 'Catering', 'Decorațiuni & Flori', 'Fotograf & Videograf', 'Muzică & Entertainment', 'Rochie & Costum', 'Altele']
                   && data.allocated >= 0;
          }

          allow read: if request.auth.uid == userId;
          allow create: if request.auth.uid == userId
                        && request.resource.data.userId == userId
                        && isValidCategory();
          allow update: if request.auth.uid == userId
                        && isValidCategory();
          allow delete: if request.auth.uid == userId;
        }
      }

      // Expenses subcollection
      match /expenses/{expenseId} {
        function isValidExpense() {
          let data = request.resource.data;
          return data.category in ['Locație', 'Catering', 'Decorațiuni & Flori', 'Fotograf & Videograf', 'Muzică & Entertainment', 'Rochie & Costum', 'Altele']
                 && data.price >= 0;
        }

        allow read: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId
                      && request.resource.data.userId == userId
                      && isValidExpense();
        allow update: if request.auth.uid == userId
                      && isValidExpense();
        allow delete: if request.auth.uid == userId;
      }
    }
  }
}
```

---

## Required Indexes

Create these composite indexes in Firebase Console or using Firebase CLI:

```javascript
// Collection: users/{userId}/guests
// Fields: status (Ascending), __name__ (Ascending)

// Collection: users/{userId}/guests
// Fields: menuPreference (Ascending), __name__ (Ascending)

// Collection: users/{userId}/guests
// Fields: isFamily (Ascending), __name__ (Ascending)

// Collection: users/{userId}/tableGuests
// Fields: tableId (Ascending), __name__ (Ascending)

// Collection: users/{userId}/tableGuests
// Fields: eventId (Ascending), __name__ (Ascending)

// Collection: users/{userId}/tableGuests
// Fields: guestId (Ascending), __name__ (Ascending)
```

---

## Next Steps for Migration

1. Set up Firebase project and enable Authentication
2. Enable Firestore database
3. Configure security rules
4. Create required indexes
5. Write migration script using Firebase Admin SDK
6. Update application code to use Firebase SDK instead of Supabase
7. Test thoroughly before production migration
8. Plan for rollback strategy
