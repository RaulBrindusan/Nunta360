"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/venue/page",{

/***/ "(app-pages-browser)/./src/hooks/useTableGuests.tsx":
/*!**************************************!*\
  !*** ./src/hooks/useTableGuests.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTableGuests: () => (/* binding */ useTableGuests)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/contexts/AuthContext */ \"(app-pages-browser)/./src/contexts/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ useTableGuests auto */ var _s = $RefreshSig$();\n\n\nconst useTableGuests = ()=>{\n    _s();\n    const [tableGuests, setTableGuests] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { user } = (0,_contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__.useAuth)();\n    // Fetch all table guests for the current user\n    const fetchTableGuests = async ()=>{\n        if (!user) {\n            setTableGuests([]);\n            setLoading(false);\n            return;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            console.log('Fetching table guests via API for user:', user.id);\n            const response = await fetch('/api/table-guests', {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            const result = await response.json();\n            if (!response.ok) {\n                console.error('Error fetching table guests:', result.error);\n                setError(result.error || 'Failed to fetch table guests');\n                setTableGuests([]);\n            } else {\n                var _result_data;\n                setTableGuests(result.data || []);\n                console.log('Fetched table guests:', ((_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.length) || 0, 'table guests');\n            }\n        } catch (err) {\n            console.error('Error fetching table guests:', err);\n            setError(err instanceof Error ? err.message : 'Failed to fetch table guests');\n            setTableGuests([]);\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Get guests for a specific table\n    const getGuestsForTable = (tableId)=>{\n        return tableGuests.filter((guest)=>guest.table_id === tableId);\n    };\n    // Add a new guest to a table\n    const addGuestToTable = async (name, tableId, tableName, eventId, guestId)=>{\n        if (!user) {\n            setError('User not authenticated');\n            return null;\n        }\n        try {\n            setError(null);\n            console.log('Adding table guest via API:', {\n                name,\n                tableId,\n                tableName,\n                eventId,\n                guestId\n            });\n            const requestData = {\n                guest_name: name.trim(),\n                table_id: tableId,\n                table_name: tableName || null,\n                event_id: eventId || null\n            };\n            // Only include guest_id if provided - temporary workaround for schema cache issue\n            if (guestId) {\n                requestData.guest_id = guestId;\n            }\n            const response = await fetch('/api/table-guests', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(requestData)\n            });\n            const result = await response.json();\n            if (!response.ok) {\n                console.error('Error adding table guest:', result.error);\n                setError(result.error || 'Failed to add guest');\n                return null;\n            }\n            // Update local state\n            setTableGuests((prev)=>[\n                    ...prev,\n                    result.data\n                ]);\n            console.log('Successfully added table guest:', result.data);\n            return result.data;\n        } catch (err) {\n            console.error('Error adding guest:', err);\n            setError(err instanceof Error ? err.message : 'Failed to add guest');\n            return null;\n        }\n    };\n    // Update a guest\n    const updateGuest = async (guestId, updates)=>{\n        if (!user) {\n            setError('User not authenticated');\n            return false;\n        }\n        try {\n            setError(null);\n            console.log('Updating table guest via API:', {\n                guestId,\n                updates\n            });\n            const response = await fetch('/api/table-guests', {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    id: guestId,\n                    updates\n                })\n            });\n            const result = await response.json();\n            if (!response.ok) {\n                console.error('Error updating table guest:', result.error);\n                setError(result.error || 'Failed to update guest');\n                return false;\n            }\n            // Update local state\n            setTableGuests((prev)=>prev.map((guest)=>guest.id === guestId ? {\n                        ...guest,\n                        ...updates,\n                        isEditing: false\n                    } : guest));\n            console.log('Successfully updated table guest:', result.data);\n            return true;\n        } catch (err) {\n            console.error('Error updating guest:', err);\n            setError(err instanceof Error ? err.message : 'Failed to update guest');\n            return false;\n        }\n    };\n    // Delete a guest\n    const deleteGuest = async (guestId)=>{\n        if (!user) {\n            setError('User not authenticated');\n            return false;\n        }\n        try {\n            setError(null);\n            console.log('Deleting table guest via API:', guestId);\n            const response = await fetch(\"/api/table-guests?id=\".concat(guestId), {\n                method: 'DELETE'\n            });\n            const result = await response.json();\n            if (!response.ok) {\n                console.error('Error deleting table guest:', result.error);\n                setError(result.error || 'Failed to delete guest');\n                return false;\n            }\n            // Update local state\n            setTableGuests((prev)=>prev.filter((guest)=>guest.id !== guestId));\n            console.log('Successfully deleted table guest');\n            return true;\n        } catch (err) {\n            console.error('Error deleting guest:', err);\n            setError(err instanceof Error ? err.message : 'Failed to delete guest');\n            return false;\n        }\n    };\n    // Move guest to different table\n    const moveGuestToTable = async (guestId, newTableId, newTableName)=>{\n        return await updateGuest(guestId, {\n            table_id: newTableId,\n            table_name: newTableName\n        });\n    };\n    // Toggle edit mode for a guest\n    const toggleEditMode = (guestId)=>{\n        setTableGuests((prev)=>prev.map((guest)=>guest.id === guestId ? {\n                    ...guest,\n                    isEditing: !guest.isEditing\n                } : {\n                    ...guest,\n                    isEditing: false\n                } // Close other editing modes\n            ));\n    };\n    // Cancel edit mode for a guest\n    const cancelEdit = (guestId)=>{\n        setTableGuests((prev)=>prev.map((guest)=>guest.id === guestId ? {\n                    ...guest,\n                    isEditing: false\n                } : guest));\n    };\n    // Get guest count for a table\n    const getGuestCountForTable = (tableId)=>{\n        return tableGuests.filter((guest)=>guest.table_id === tableId).length;\n    };\n    // Get total guest count\n    const getTotalGuestCount = ()=>{\n        return tableGuests.length;\n    };\n    // Clear all guests (for development/testing)\n    const clearAllGuests = async ()=>{\n        if (!user) {\n            setError('User not authenticated');\n            return false;\n        }\n        try {\n            setError(null);\n            // Get user record to get internal user ID\n            let userData, userError;\n            const { data: userByEmail, error: emailError } = await supabase.from('users').select('id').eq('email', user.email).single();\n            if (emailError) {\n                const result = await supabase.from('users').select('id').eq('auth_id', user.id).single();\n                userData = result.data;\n                userError = result.error;\n            } else {\n                userData = userByEmail;\n                userError = emailError;\n            }\n            if (userError || !userData) {\n                setError('User not found in database');\n                return false;\n            }\n            const { error: deleteError } = await supabase.from('table_guests').delete().eq('user_id', userData.id);\n            if (deleteError) throw deleteError;\n            setTableGuests([]);\n            return true;\n        } catch (err) {\n            console.error('Error clearing guests:', err);\n            setError(err instanceof Error ? err.message : 'Failed to clear guests');\n            return false;\n        }\n    };\n    // Initial load\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useTableGuests.useEffect\": ()=>{\n            fetchTableGuests();\n        }\n    }[\"useTableGuests.useEffect\"], [\n        user\n    ]);\n    return {\n        tableGuests,\n        loading,\n        error,\n        fetchTableGuests,\n        getGuestsForTable,\n        addGuestToTable,\n        updateGuest,\n        deleteGuest,\n        moveGuestToTable,\n        toggleEditMode,\n        cancelEdit,\n        getGuestCountForTable,\n        getTotalGuestCount,\n        clearAllGuests\n    };\n};\n_s(useTableGuests, \"pmD7pWvHQ2905aIrXV5QnF/MLPc=\", false, function() {\n    return [\n        _contexts_AuthContext__WEBPACK_IMPORTED_MODULE_1__.useAuth\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VUYWJsZUd1ZXN0cy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFNEM7QUFDSztBQWdDMUMsTUFBTUcsaUJBQWlCOztJQUM1QixNQUFNLENBQUNDLGFBQWFDLGVBQWUsR0FBR0wsK0NBQVFBLENBQTBCLEVBQUU7SUFDMUUsTUFBTSxDQUFDTSxTQUFTQyxXQUFXLEdBQUdQLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ1EsT0FBT0MsU0FBUyxHQUFHVCwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxFQUFFVSxJQUFJLEVBQUUsR0FBR1IsOERBQU9BO0lBRXhCLDhDQUE4QztJQUM5QyxNQUFNUyxtQkFBbUI7UUFDdkIsSUFBSSxDQUFDRCxNQUFNO1lBQ1RMLGVBQWUsRUFBRTtZQUNqQkUsV0FBVztZQUNYO1FBQ0Y7UUFFQSxJQUFJO1lBQ0ZBLFdBQVc7WUFDWEUsU0FBUztZQUVURyxRQUFRQyxHQUFHLENBQUMsMkNBQTJDSCxLQUFLSSxFQUFFO1lBRTlELE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxxQkFBcUI7Z0JBQ2hEQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBLE1BQU1DLFNBQVMsTUFBTUosU0FBU0ssSUFBSTtZQUVsQyxJQUFJLENBQUNMLFNBQVNNLEVBQUUsRUFBRTtnQkFDaEJULFFBQVFKLEtBQUssQ0FBQyxnQ0FBZ0NXLE9BQU9YLEtBQUs7Z0JBQzFEQyxTQUFTVSxPQUFPWCxLQUFLLElBQUk7Z0JBQ3pCSCxlQUFlLEVBQUU7WUFDbkIsT0FBTztvQkFFZ0NjO2dCQURyQ2QsZUFBZWMsT0FBT0csSUFBSSxJQUFJLEVBQUU7Z0JBQ2hDVixRQUFRQyxHQUFHLENBQUMseUJBQXlCTSxFQUFBQSxlQUFBQSxPQUFPRyxJQUFJLGNBQVhILG1DQUFBQSxhQUFhSSxNQUFNLEtBQUksR0FBRztZQUNqRTtRQUNGLEVBQUUsT0FBT0MsS0FBSztZQUNaWixRQUFRSixL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dUMsWUFBWTFDLE9BQU9YLEtBQUs7WUFDMUIsT0FBTztnQkFDTG9ELFdBQVdFO2dCQUNYRCxZQUFZRTtZQUNkO1lBRUEsSUFBSUYsYUFBYSxDQUFDRCxVQUFVO2dCQUMxQm5ELFNBQVM7Z0JBQ1QsT0FBTztZQUNUO1lBRUEsTUFBTSxFQUFFRCxPQUFPOEQsV0FBVyxFQUFFLEdBQUcsTUFBTU4sU0FDbENDLElBQUksQ0FBQyxnQkFDTE0sTUFBTSxHQUNOSixFQUFFLENBQUMsV0FBV1AsU0FBUzlDLEVBQUU7WUFFNUIsSUFBSXdELGFBQWEsTUFBTUE7WUFFdkJqRSxlQUFlLEVBQUU7WUFDakIsT0FBTztRQUNULEVBQUUsT0FBT21CLEtBQUs7WUFDWlosUUFBUUosS0FBSyxDQUFDLDBCQUEwQmdCO1lBQ3hDZixTQUFTZSxlQUFlQyxRQUFRRCxJQUFJRSxPQUFPLEdBQUc7WUFDOUMsT0FBTztRQUNUO0lBQ0Y7SUFFQSxlQUFlO0lBQ2Z6QixnREFBU0E7b0NBQUM7WUFDUlU7UUFDRjttQ0FBRztRQUFDRDtLQUFLO0lBRVQsT0FBTztRQUNMTjtRQUNBRTtRQUNBRTtRQUNBRztRQUNBZ0I7UUFDQUs7UUFDQWU7UUFDQUk7UUFDQUM7UUFDQUc7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtBQUNGLEVBQUU7R0F0VFd4RDs7UUFJTUQsMERBQU9BIiwic291cmNlcyI6WyJEOlxcV2ViIERldiBQcm9qZWN0c1xcbnVudGEzNjBcXHNyY1xcaG9va3NcXHVzZVRhYmxlR3Vlc3RzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnQC9jb250ZXh0cy9BdXRoQ29udGV4dCc7XG5pbXBvcnQge1xuICBjb2xsZWN0aW9uLFxuICBxdWVyeSxcbiAgb25TbmFwc2hvdCxcbiAgYWRkRG9jLFxuICB1cGRhdGVEb2MsXG4gIGRlbGV0ZURvYyxcbiAgZG9jLFxuICBzZXJ2ZXJUaW1lc3RhbXAsXG4gIFRpbWVzdGFtcCxcbiAgd2hlcmUsXG4gIGdldERvY3MsXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvbGliL2ZpcmViYXNlJztcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUd1ZXN0IHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdGFibGVJZDogc3RyaW5nO1xuICB0YWJsZU5hbWU/OiBzdHJpbmc7XG4gIGV2ZW50SWQ/OiBzdHJpbmc7XG4gIGd1ZXN0SWQ/OiBzdHJpbmc7XG4gIGNyZWF0ZWRBdDogVGltZXN0YW1wO1xuICB1cGRhdGVkQXQ6IFRpbWVzdGFtcDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUd1ZXN0V2l0aEFjdGlvbnMgZXh0ZW5kcyBUYWJsZUd1ZXN0IHtcbiAgaXNFZGl0aW5nPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVRhYmxlR3Vlc3RzID0gKCkgPT4ge1xuICBjb25zdCBbdGFibGVHdWVzdHMsIHNldFRhYmxlR3Vlc3RzXSA9IHVzZVN0YXRlPFRhYmxlR3Vlc3RXaXRoQWN0aW9uc1tdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZUF1dGgoKTtcblxuICAvLyBGZXRjaCBhbGwgdGFibGUgZ3Vlc3RzIGZvciB0aGUgY3VycmVudCB1c2VyXG4gIGNvbnN0IGZldGNoVGFibGVHdWVzdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBzZXRUYWJsZUd1ZXN0cyhbXSk7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgdGFibGUgZ3Vlc3RzIHZpYSBBUEkgZm9yIHVzZXI6JywgdXNlci5pZCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdGFibGUtZ3Vlc3RzJywge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFibGUgZ3Vlc3RzOicsIHJlc3VsdC5lcnJvcik7XG4gICAgICAgIHNldEVycm9yKHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIHRhYmxlIGd1ZXN0cycpO1xuICAgICAgICBzZXRUYWJsZUd1ZXN0cyhbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUYWJsZUd1ZXN0cyhyZXN1bHQuZGF0YSB8fCBbXSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHRhYmxlIGd1ZXN0czonLCByZXN1bHQuZGF0YT8ubGVuZ3RoIHx8IDAsICd0YWJsZSBndWVzdHMnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRhYmxlIGd1ZXN0czonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gZmV0Y2ggdGFibGUgZ3Vlc3RzJyk7XG4gICAgICBzZXRUYWJsZUd1ZXN0cyhbXSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBHZXQgZ3Vlc3RzIGZvciBhIHNwZWNpZmljIHRhYmxlXG4gIGNvbnN0IGdldEd1ZXN0c0ZvclRhYmxlID0gKHRhYmxlSWQ6IHN0cmluZyk6IFRhYmxlR3Vlc3RXaXRoQWN0aW9uc1tdID0+IHtcbiAgICByZXR1cm4gdGFibGVHdWVzdHMuZmlsdGVyKGd1ZXN0ID0+IGd1ZXN0LnRhYmxlX2lkID09PSB0YWJsZUlkKTtcbiAgfTtcblxuICAvLyBBZGQgYSBuZXcgZ3Vlc3QgdG8gYSB0YWJsZVxuICBjb25zdCBhZGRHdWVzdFRvVGFibGUgPSBhc3luYyAoXG4gICAgbmFtZTogc3RyaW5nLCBcbiAgICB0YWJsZUlkOiBzdHJpbmcsIFxuICAgIHRhYmxlTmFtZT86IHN0cmluZywgXG4gICAgZXZlbnRJZD86IHN0cmluZyxcbiAgICBndWVzdElkPzogc3RyaW5nXG4gICk6IFByb21pc2U8VGFibGVHdWVzdCB8IG51bGw+ID0+IHtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHNldEVycm9yKCdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgdGFibGUgZ3Vlc3QgdmlhIEFQSTonLCB7IG5hbWUsIHRhYmxlSWQsIHRhYmxlTmFtZSwgZXZlbnRJZCwgZ3Vlc3RJZCB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdERhdGE6IGFueSA9IHtcbiAgICAgICAgZ3Vlc3RfbmFtZTogbmFtZS50cmltKCksXG4gICAgICAgIHRhYmxlX2lkOiB0YWJsZUlkLFxuICAgICAgICB0YWJsZV9uYW1lOiB0YWJsZU5hbWUgfHwgbnVsbCxcbiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQgfHwgbnVsbCxcbiAgICAgIH07XG5cbiAgICAgIC8vIE9ubHkgaW5jbHVkZSBndWVzdF9pZCBpZiBwcm92aWRlZCAtIHRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBzY2hlbWEgY2FjaGUgaXNzdWVcbiAgICAgIGlmIChndWVzdElkKSB7XG4gICAgICAgIHJlcXVlc3REYXRhLmd1ZXN0X2lkID0gZ3Vlc3RJZDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS90YWJsZS1ndWVzdHMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdERhdGEpLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGFibGUgZ3Vlc3Q6JywgcmVzdWx0LmVycm9yKTtcbiAgICAgICAgc2V0RXJyb3IocmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gYWRkIGd1ZXN0Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcbiAgICAgIHNldFRhYmxlR3Vlc3RzKHByZXYgPT4gWy4uLnByZXYsIHJlc3VsdC5kYXRhXSk7XG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGFkZGVkIHRhYmxlIGd1ZXN0OicsIHJlc3VsdC5kYXRhKTtcbiAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBndWVzdDonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gYWRkIGd1ZXN0Jyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXBkYXRlIGEgZ3Vlc3RcbiAgY29uc3QgdXBkYXRlR3Vlc3QgPSBhc3luYyAoXG4gICAgZ3Vlc3RJZDogc3RyaW5nLCBcbiAgICB1cGRhdGVzOiBQYXJ0aWFsPFBpY2s8VGFibGVHdWVzdFVwZGF0ZSwgJ25hbWUnIHwgJ3RhYmxlX2lkJyB8ICd0YWJsZV9uYW1lJz4+XG4gICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0RXJyb3IoJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyB0YWJsZSBndWVzdCB2aWEgQVBJOicsIHsgZ3Vlc3RJZCwgdXBkYXRlcyB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS90YWJsZS1ndWVzdHMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGlkOiBndWVzdElkLCB1cGRhdGVzIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0YWJsZSBndWVzdDonLCByZXN1bHQuZXJyb3IpO1xuICAgICAgICBzZXRFcnJvcihyZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgZ3Vlc3QnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcbiAgICAgIHNldFRhYmxlR3Vlc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKGd1ZXN0ID0+IFxuICAgICAgICAgIGd1ZXN0LmlkID09PSBndWVzdElkIFxuICAgICAgICAgICAgPyB7IC4uLmd1ZXN0LCAuLi51cGRhdGVzLCBpc0VkaXRpbmc6IGZhbHNlIH1cbiAgICAgICAgICAgIDogZ3Vlc3RcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSB1cGRhdGVkIHRhYmxlIGd1ZXN0OicsIHJlc3VsdC5kYXRhKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZ3Vlc3Q6JywgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHVwZGF0ZSBndWVzdCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWxldGUgYSBndWVzdFxuICBjb25zdCBkZWxldGVHdWVzdCA9IGFzeW5jIChndWVzdElkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHNldEVycm9yKCdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICBjb25zb2xlLmxvZygnRGVsZXRpbmcgdGFibGUgZ3Vlc3QgdmlhIEFQSTonLCBndWVzdElkKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS90YWJsZS1ndWVzdHM/aWQ9JHtndWVzdElkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdGFibGUgZ3Vlc3Q6JywgcmVzdWx0LmVycm9yKTtcbiAgICAgICAgc2V0RXJyb3IocmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gZGVsZXRlIGd1ZXN0Jyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXG4gICAgICBzZXRUYWJsZUd1ZXN0cyhwcmV2ID0+IHByZXYuZmlsdGVyKGd1ZXN0ID0+IGd1ZXN0LmlkICE9PSBndWVzdElkKSk7XG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgdGFibGUgZ3Vlc3QnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgZ3Vlc3Q6JywgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGRlbGV0ZSBndWVzdCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBNb3ZlIGd1ZXN0IHRvIGRpZmZlcmVudCB0YWJsZVxuICBjb25zdCBtb3ZlR3Vlc3RUb1RhYmxlID0gYXN5bmMgKFxuICAgIGd1ZXN0SWQ6IHN0cmluZywgXG4gICAgbmV3VGFibGVJZDogc3RyaW5nLCBcbiAgICBuZXdUYWJsZU5hbWU/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUd1ZXN0KGd1ZXN0SWQsIHsgXG4gICAgICB0YWJsZV9pZDogbmV3VGFibGVJZCwgXG4gICAgICB0YWJsZV9uYW1lOiBuZXdUYWJsZU5hbWUgXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIGVkaXQgbW9kZSBmb3IgYSBndWVzdFxuICBjb25zdCB0b2dnbGVFZGl0TW9kZSA9IChndWVzdElkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRUYWJsZUd1ZXN0cyhwcmV2ID0+IFxuICAgICAgcHJldi5tYXAoZ3Vlc3QgPT4gXG4gICAgICAgIGd1ZXN0LmlkID09PSBndWVzdElkIFxuICAgICAgICAgID8geyAuLi5ndWVzdCwgaXNFZGl0aW5nOiAhZ3Vlc3QuaXNFZGl0aW5nIH1cbiAgICAgICAgICA6IHsgLi4uZ3Vlc3QsIGlzRWRpdGluZzogZmFsc2UgfSAvLyBDbG9zZSBvdGhlciBlZGl0aW5nIG1vZGVzXG4gICAgICApXG4gICAgKTtcbiAgfTtcblxuICAvLyBDYW5jZWwgZWRpdCBtb2RlIGZvciBhIGd1ZXN0XG4gIGNvbnN0IGNhbmNlbEVkaXQgPSAoZ3Vlc3RJZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0VGFibGVHdWVzdHMocHJldiA9PiBcbiAgICAgIHByZXYubWFwKGd1ZXN0ID0+IFxuICAgICAgICBndWVzdC5pZCA9PT0gZ3Vlc3RJZCBcbiAgICAgICAgICA/IHsgLi4uZ3Vlc3QsIGlzRWRpdGluZzogZmFsc2UgfVxuICAgICAgICAgIDogZ3Vlc3RcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIC8vIEdldCBndWVzdCBjb3VudCBmb3IgYSB0YWJsZVxuICBjb25zdCBnZXRHdWVzdENvdW50Rm9yVGFibGUgPSAodGFibGVJZDogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICByZXR1cm4gdGFibGVHdWVzdHMuZmlsdGVyKGd1ZXN0ID0+IGd1ZXN0LnRhYmxlX2lkID09PSB0YWJsZUlkKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gR2V0IHRvdGFsIGd1ZXN0IGNvdW50XG4gIGNvbnN0IGdldFRvdGFsR3Vlc3RDb3VudCA9ICgpOiBudW1iZXIgPT4ge1xuICAgIHJldHVybiB0YWJsZUd1ZXN0cy5sZW5ndGg7XG4gIH07XG5cbiAgLy8gQ2xlYXIgYWxsIGd1ZXN0cyAoZm9yIGRldmVsb3BtZW50L3Rlc3RpbmcpXG4gIGNvbnN0IGNsZWFyQWxsR3Vlc3RzID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0RXJyb3IoJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIC8vIEdldCB1c2VyIHJlY29yZCB0byBnZXQgaW50ZXJuYWwgdXNlciBJRFxuICAgICAgbGV0IHVzZXJEYXRhLCB1c2VyRXJyb3I7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogdXNlckJ5RW1haWwsIGVycm9yOiBlbWFpbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgIC5lcSgnZW1haWwnLCB1c2VyLmVtYWlsKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgIFxuICAgICAgaWYgKGVtYWlsRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAuZXEoJ2F1dGhfaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgdXNlckRhdGEgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgdXNlckVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXNlckRhdGEgPSB1c2VyQnlFbWFpbDtcbiAgICAgICAgdXNlckVycm9yID0gZW1haWxFcnJvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZXJFcnJvciB8fCAhdXNlckRhdGEpIHtcbiAgICAgICAgc2V0RXJyb3IoJ1VzZXIgbm90IGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0YWJsZV9ndWVzdHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlckRhdGEuaWQpO1xuXG4gICAgICBpZiAoZGVsZXRlRXJyb3IpIHRocm93IGRlbGV0ZUVycm9yO1xuXG4gICAgICBzZXRUYWJsZUd1ZXN0cyhbXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGd1ZXN0czonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gY2xlYXIgZ3Vlc3RzJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIEluaXRpYWwgbG9hZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoVGFibGVHdWVzdHMoKTtcbiAgfSwgW3VzZXJdKTtcblxuICByZXR1cm4ge1xuICAgIHRhYmxlR3Vlc3RzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgZmV0Y2hUYWJsZUd1ZXN0cyxcbiAgICBnZXRHdWVzdHNGb3JUYWJsZSxcbiAgICBhZGRHdWVzdFRvVGFibGUsXG4gICAgdXBkYXRlR3Vlc3QsXG4gICAgZGVsZXRlR3Vlc3QsXG4gICAgbW92ZUd1ZXN0VG9UYWJsZSxcbiAgICB0b2dnbGVFZGl0TW9kZSxcbiAgICBjYW5jZWxFZGl0LFxuICAgIGdldEd1ZXN0Q291bnRGb3JUYWJsZSxcbiAgICBnZXRUb3RhbEd1ZXN0Q291bnQsXG4gICAgY2xlYXJBbGxHdWVzdHMsXG4gIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUF1dGgiLCJ1c2VUYWJsZUd1ZXN0cyIsInRhYmxlR3Vlc3RzIiwic2V0VGFibGVHdWVzdHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJ1c2VyIiwiZmV0Y2hUYWJsZUd1ZXN0cyIsImNvbnNvbGUiLCJsb2ciLCJpZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwicmVzdWx0IiwianNvbiIsIm9rIiwiZGF0YSIsImxlbmd0aCIsImVyciIsIkVycm9yIiwibWVzc2FnZSIsImdldEd1ZXN0c0ZvclRhYmxlIiwidGFibGVJZCIsImZpbHRlciIsImd1ZXN0IiwidGFibGVfaWQiLCJhZGRHdWVzdFRvVGFibGUiLCJuYW1lIiwidGFibGVOYW1lIiwiZXZlbnRJZCIsImd1ZXN0SWQiLCJyZXF1ZXN0RGF0YSIsImd1ZXN0X25hbWUiLCJ0cmltIiwidGFibGVfbmFtZSIsImV2ZW50X2lkIiwiZ3Vlc3RfaWQiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXYiLCJ1cGRhdGVHdWVzdCIsInVwZGF0ZXMiLCJtYXAiLCJpc0VkaXRpbmciLCJkZWxldGVHdWVzdCIsIm1vdmVHdWVzdFRvVGFibGUiLCJuZXdUYWJsZUlkIiwibmV3VGFibGVOYW1lIiwidG9nZ2xlRWRpdE1vZGUiLCJjYW5jZWxFZGl0IiwiZ2V0R3Vlc3RDb3VudEZvclRhYmxlIiwiZ2V0VG90YWxHdWVzdENvdW50IiwiY2xlYXJBbGxHdWVzdHMiLCJ1c2VyRGF0YSIsInVzZXJFcnJvciIsInVzZXJCeUVtYWlsIiwiZW1haWxFcnJvciIsInN1cGFiYXNlIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiZW1haWwiLCJzaW5nbGUiLCJkZWxldGVFcnJvciIsImRlbGV0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useTableGuests.tsx\n"));

/***/ })

});